"""
a klusterbox module: Klusterbox Converter for Employee Everything Reports from PDF to CSV format
this module contains the pdf converter which reads employee everything reports in the pdf format and converts them
into csv formatted employee everything reports which can be read by the automatic data entry, auto overmax finder and
the employee everything reader.
"""
from kbtoolbox import inquire, dir_filedialog, find_pp, PdfConverterFix, titlebar_icon, Convert, ProgressBarDe
# Standard Libraries
from tkinter import messagebox, filedialog, ttk, Label, Tk
from datetime import timedelta
import os
import csv
from io import StringIO  # change from cStringIO to io for py 3x
import time
import re
# PDF Converter Libraries
from pdfminer.pdfparser import PDFParser
from pdfminer.pdfdocument import PDFDocument
from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter, resolve1
from pdfminer.converter import TextConverter
from pdfminer.layout import LAParams
from pdfminer.pdfpage import PDFPage


class PdfConverter:
    """ take a weekly employee everything report and convert it into the csv format. """

    def __init__(self):
        self.frame = None
        self.gen_error_report = None  # option to generate error report
        self.gen_raw_report = None  # option to generate raw text file from pdf miner output
        self.allow_txt_reader = None  # directs the pdf converter to read from text file instead of pdf file
        self.starttime = None
        self.endtime = None
        self.text = None  # text generated by pdfminer or a text file of pdfminer output
        self.file_path = None  # the input file with path
        self.new_file_path = None  # the new output file name with the path
        self.short_file_name = None  # the new output file name without the path
        self.kbpc_rpt = None
        self.kbpc_rpt_file_path = None
        self.kbpc_raw_rpt_file_path = None
        self.writer = None
        self.page = None  # the documemnt is split into pages.
        self.pb = None  # progress bar object
        self.pbi = 0  # progress bar count index
        self.movecode_holder = None
        self.date_holder = []
        self.underscore_slash_result = None
        self.yyppwk = None
        self.page_num = 1  # initialize var to count pages
        self.eid_count = 0  # initialize var to count underscore dash items
        self.daily_underscoreslash = []
        self.mv_holder = []
        self.time_holder = []
        self.timezone_holder = []
        self.finance_holder = []
        self.foundday_holder = []
        self.daily_array = []
        self.franklin_array = []
        self.mv_desigs = ("BT", "MV", "ET", "OT", "OL", "IL", "DG")
        self.days = ("Saturday", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
        self.saved_pp = ""  # hold the pp to identify if it changes
        self.pp_days = []  # array of date/time objs for each day in the week
        self.found_days = []  # array for holding days worked
        self.base_time = []  # array for holding hours worked during the day
        self.eid = ""  # hold the employee id
        self.lastname = ""  # holds the last name of the employee
        self.fi = ""
        self.jobs = []  # holds the d/a code
        self.routes = []  # holds the route
        self.level = []  # hold the level (one or two normally)
        self.base_temp = ("Base", "Temp")
        self.eid_label = False
        self.lookforname = False
        self.lookforfi = False
        self.lookforroute = False
        self.lookfor2route = False
        self.lookforlevel = False
        self.lookfor2level = False
        self.base_counter = 0
        self.base_chg = 0
        self.lookfortimes = False
        self.unprocessedrings = ""
        self.new_page = False
        self.unprocessed_counter = 0
        self.mcgrath_indicator = False
        self.mcgrath_carryover = ""
        self.rod_rpt = []  # error reports
        self.frank_rpt = []
        self.rose_rpt = []
        self.robert_rpt = []
        self.stevens_rpt = []
        self.carroll_rpt = []
        self.nguyen_rpt = []
        self.salih_rpt = []
        self.unruh_rpt = []
        self.mcgrath_rpt = []
        self.unresolved = []
        self.basecounter_error = []
        self.failed = []
        self.daily_array_days = []  # build an array of formatted days with just month/ day
        csv.register_dialect('myDialect',
                             delimiter=',',
                             quoting=csv.QUOTE_NONE,
                             skipinitialspace=True,
                             lineterminator="\r"
                             )

    def run(self, frame):
        """ this is a master method for running the other methods in the proper order. """
        self.frame = frame
        self.get_settings()  # gets preferences from tolerances table.
        if self.allow_txt_reader:  # if you have opted to read from a text file instead of a pdf file...
            if not self.read_from_txt():  # allows the user to read the pdf output from a text file instead of a pdf
                return
        if self.gen_raw_report:  # put the raw output from the pdf conversion into a text file
            self.create_raw_report()
        if self.gen_error_report:  # create text document for data extracted from the raw pdfminer output
            self.create_error_report()
        self.create_new_file()  # create and start the csv file that is created by the pdf converter.
        self.split_document()  # split the document into pages.
        if not self.validate_text():  # search for a station name to make sure the doc is an ee report
            return
        # start the progress bar
        self.pb = ProgressBarDe(title="Klusterbox PDF Converter - translating pdf",
                                label="Translating PDF: ",
                                text="This process takes several minutes. Please wait for results.")
        self.pb.max_count(len(self.page) - 1)  # set length of progress bar
        self.pb.start_up()  # start the progress bar
        self.pbi = 1
        self.pb.move_count(self.pbi)  # increment progress bar
        self.pb.change_text("This process takes several minutes. Please wait for results.")
        self.anaylse_page()  # go page by page for analysis.
        self.pb.stop()
        self.build_error_report()  # if the error report is opted - generate it.
        self.error_messagebox()  # prompt user with messagebox if any carriers failed to be read.
        self.completion_messagebox()  # prompt user with messagebox to show successful completion.
        
    def get_settings(self):
        """ inquire as to if the pdf converter reports have been opted for by the user """ 
        sql = "SELECT tolerance FROM tolerances WHERE category ='%s'" % "pdf_error_rpt"
        result = inquire(sql)
        self.gen_error_report = Convert(result[0][0]).onoff_to_bool()
        sql = "SELECT tolerance FROM tolerances WHERE category ='%s'" % "pdf_raw_rpt"
        result = inquire(sql)
        self.gen_raw_report = Convert(result[0][0]).onoff_to_bool()
        self.starttime = time.time()  # start the timer
        # make it possible for user to select text file
        sql = "SELECT tolerance FROM tolerances WHERE category ='%s'" % "pdf_text_reader"
        result = inquire(sql)
        self.allow_txt_reader = Convert(result[0][0]).onoff_to_bool()

    def read_from_txt(self):
        """ allows the user to read the output of pdfminer from a text file instead of the pdf file """
        if not messagebox.askyesno("PDF Converter",
                               "Did you want to read from a text file of data output by pdfminer?",
                               parent=self.frame):
            self.file_path = filedialog.askopenfilename(initialdir=dir_filedialog(),
                                                        filetypes=[("PDF files", "*.pdf")])  # get the pdf file
            # generate csv file name and path
            self.new_file_path = self.pdf_converter_path_generator(self.file_path, "_kbpc", ".csv")
            self.short_file_name = self.pdf_converter_short_name()
            # if the file path already exist - ask for confirmation
            if os.path.exists(self.new_file_path):
                if not messagebox.askokcancel("Possible File Name Discrepancy",
                                              "There is already a file named {}. "
                                              "If you proceed, the file will be overwritten. "
                                              "Did you want to proceed?".format(self.short_file_name),
                                              parent=self.frame):
                    return False
            # warn user that the process can take several minutes
            if not messagebox.askokcancel("PDF Converter", "This process will take several minutes. "
                                                           "Did you want to proceed?",
                                          parent=self.frame):
                return False
            else:
                self.text = self.pdf_to_text()  # read the pdf with pdfminer
        else:  # user opts to read from text file
            path = dir_filedialog()
            self.file_path = filedialog.askopenfilename(initialdir=path,
                                                        filetypes=[("text files", "*.txt")])  # get the pdf file
            # generate csv file name and path
            self.new_file_path = self.pdf_converter_path_generator(self.file_path, "_kbpc", ".csv")
            self.short_file_name = self.pdf_converter_short_name()
            # if the file path already exist - ask for confirmation
            if os.path.exists(self.new_file_path):
                if not messagebox.askokcancel(
                        "Possible File Name Discrepancy",
                        "There is already a file named {}. If you proceed, the file will be overwritten. "
                        "Did you want to proceed?".format(self.short_file_name),
                        parent=self.frame):
                    return False
            self.gen_raw_report = False  # since you are reading a raw report, turn off the generator
            with open(self.file_path, 'r') as file:  # read the txt file and put it in the text variable
                self.text = file.read()
        return True

    def pdf_to_text(self):
        """ Called by pdf_converter() to read pdfs with pdfminer """
        text = None
        codec = 'utf-8'
        password = ""
        maxpages = 0
        caching = (True, True)
        pagenos = set()
        laparams = (
            LAParams(
                line_overlap=.1,  # best results
                char_margin=2,
                line_margin=.5,
                word_margin=.5,
                boxes_flow=0,
                detect_vertical=True,
                all_texts=True),
            LAParams(
                line_overlap=.5,  # default settings
                char_margin=2,
                line_margin=.5,
                word_margin=.5,
                boxes_flow=.5  # detect_vertical=False (default), all_texts=False (default)
            )
        )
        for i in range(2):
            retstr = StringIO()
            rsrcmgr = PDFResourceManager()
            device = TextConverter(rsrcmgr, retstr, codec=codec, laparams=laparams[i])
            interpreter = PDFPageInterpreter(rsrcmgr, device)
            page_count = self.pdf_converter_pagecount()  # get page count
            with open(self.file_path, 'rb') as filein:
                # create progressbar
                pb_root = Tk()  # create a window for the progress bar
                pb_root.geometry("%dx%d+%d+%d" % (450, 75, 200, 300))
                pb_root.title("Klusterbox PDF Converter - reading pdf")
                titlebar_icon(pb_root)  # place icon in titlebar
                Label(pb_root, text="This process takes several minutes. Please wait for results.") \
                    .grid(row=0, column=0, columnspan=2, sticky="w")
                pb_label = Label(pb_root, text="Reading PDF: ")  # make label for progress bar
                pb_label.grid(row=1, column=0, sticky="w")
                pb = ttk.Progressbar(pb_root, length=350, mode="determinate")  # create progress bar
                pb.grid(row=1, column=1, sticky="w")
                pb_text = Label(pb_root, text="", anchor="w")
                pb_text.grid(row=2, column=0, columnspan=2, sticky="w")
                pb["maximum"] = page_count  # set length of progress bar
                pb.start()
                count = 0
                # check_extractable=True (default setting)
                for page in PDFPage.get_pages(filein, pagenos, maxpages=maxpages, password=password,
                                              caching=caching[i]):
                    interpreter.process_page(page)
                    pb["value"] = count  # increment progress bar
                    pb_text.config(text="Reading page: {}/{}".format(count, page_count))
                    pb_root.update()
                    count += 1
                text = retstr.getvalue()
                device.close()
                retstr.close()
            pb.stop()  # stop and destroy the progress bar
            pb_label.destroy()  # destroy the label for the progress bar
            pb.destroy()
            pb_root.destroy()
            # test the results
            text = text.replace("", "")
            page = text.split("")  # split the document into page
            result = re.search("Restricted USPS T&A Information(.*)Employee Everything Report", page[0], re.DOTALL)
            try:
                station = result.group(1).strip()
                break
            except:
                if i < 1:
                    result = messagebox.askokcancel("Klusterbox PDF Converter",
                                                    "PDF Conversion has failed and will not generate a file.  \n\n"
                                                    "We will try again.",
                                                    parent=self.frame)
                    if not result:
                        return text
                else:
                    messagebox.showerror("Klusterbox PDF Converter",
                                         "PDF Conversion has failed and will not generate a file.  \n\n"
                                         "You will either have to obtain the Employee Everything Report "
                                         "in the csv format from management or manually enter in the "
                                         "information",
                                         parent=self.frame)

        return text

    def pdf_converter_pagecount(self):
        """ gives a page count for pdf_to_text """
        file = open(self.file_path, 'rb')
        parser = PDFParser(file)
        document = PDFDocument(parser)
        page_count = resolve1(document.catalog['Pages'])['Count']  # This will give you the count of pages
        return page_count

    def pdf_converter_path_generator(self, filepath, add_on, extension):
        """ generate csv file name and path """
        file_parts = filepath.split("/")  # split path into folders and file
        file_name_xten = file_parts[len(file_parts) - 1]  # get the file name from the end of the path
        file_name = file_name_xten[:-4]  # remove the file extension from the file name
        file_name = file_name.replace("_raw_kbpc", "")
        path = filepath[:-len(file_name_xten)]  # get the path back to the source folder
        new_fname = file_name + add_on  # add suffix to to show converted pdf to csv
        new_file_path = path + new_fname + extension  # new path with modified file name
        return new_file_path

    def pdf_converter_short_name(self):
        """ get the last part of the file name"""
        file_parts = self.new_file_path.split("/")  # split path into folders and file
        file_name_xten = file_parts[len(file_parts) - 1]  # get the file name from the end of the path
        return file_name_xten

    def create_raw_report(self):
        """ put the raw output from the pdf conversion into a text file """
        # generate csv file name and path
        self.kbpc_raw_rpt_file_path = self.pdf_converter_path_generator(file_path, "_raw_kbpc", ".txt")
        kbpc_raw_rpt = open(self.kbpc_raw_rpt_file_path, "w")
        kbpc_raw_rpt.write("KLUSTERBOX PDF CONVERSION REPORT \n\n")
        kbpc_raw_rpt.write("Raw output from pdf miner\n\n")
        datainput = "subject file: {}\n\n".format(file_path)
        kbpc_raw_rpt.write(datainput)
        kbpc_raw_rpt.write(self.text)
        kbpc_raw_rpt.close()
        
    def create_error_report(self):
        """ create text document for data extracted from the raw pdfminer output """
        self.kbpc_rpt_file_path = self.pdf_converter_path_generator(self.file_path, "_kbpc", ".txt")
        self.kbpc_rpt = open(self.kbpc_rpt_file_path, "w")
        self.kbpc_rpt.write("KLUSTERBOX PDF CONVERSION REPORT \n\n")
        self.kbpc_rpt.write("Data extracted from pdfminer output and error reports\n\n")
        datainput = "subject file: {}\n\n".format(self.file_path)
        self.kbpc_rpt.write(datainput)

    def create_new_file(self):
        """ create the new csv file that is generated by the pdf converter. """
        # define csv writer parameters
        # csv.register_dialect('myDialect',
        #                     delimiter=',',
        #                     quoting=csv.QUOTE_NONE,
        #                     skipinitialspace=True,
        #                     lineterminator="\r"
        #                     )
        # create the csv file and write the first line
        line = ["TAC500R3 - Employee Everything Report"]
        with open(self.new_file_path, 'w') as writeFile:
            self.writer = csv.writer(writeFile, dialect='myDialect')
            self.writer.writerow(line)
        # define csv writer parameters
        # csv.register_dialect('myDialect',
        #                      delimiter=',',
        #                      quoting=csv.QUOTE_ALL,
        #                      skipinitialspace=True,
        #                      lineterminator=",\r"
        #                      )
        line = ["YrPPWk", "Finance No", "Organization Name", "Sub-Unit", "Employee Id", "Last Name", "FI", "MI",
                "Pay Loc/Fin Unit", "Var. EAS", "Borrowed", "Auto H/L", "Annual Lv Bal", "Sick Lv Bal", "LWOP Lv Bal",
                "FMLA Hrs", "FMLA Used", "SLDC Used", "Job", "D/A", "LDC", "Oper/Lu", "RSC", "Lvl", "FLSA", "Route #",
                "Loaned Fin #", "Effective Start", "Effective End", "Begin Tour", "End Tour", "Lunch Amt", "1261 Ind",
                "Lunch Ind", "Daily Sched Ind", "Time Zone", "FTF", "OOS", "Day", ]
        with open(self.new_file_path, 'a') as writeFile:
            self.writer = csv.writer(writeFile, dialect='myDialect')
            self.writer.writerow(line)

    def split_document(self):
        """ split the document into pages. """
        self.text = self.text.replace("", "")
        self.page = self.text.split("")  # split the document into pages

    def validate_text(self):
        """ search for a station name to make sure the doc is an ee report """
        result = re.search('Restricted USPS T&A Information(.*?)Employee Everything Report', self.page[0], re.DOTALL)
        try:
            station = result.group(1).strip()
        except:
            messagebox.showerror("Klusterbox PDF Converter",
                                 "This file does not appear to be an Employee Everything Report. \n\n"
                                 "The PDF Converter will not generate a file",
                                 parent=self.frame)
            os.remove(self.new_file_path)
            if self.gen_error_report:
                self.kbpc_rpt.close()
                os.remove(self.kbpc_rpt_file_path)
            if self.gen_raw_report:
                os.remove(self.kbpc_raw_rpt_file_path)
            return False
        return True

    def anaylse_page(self):
        """ go page by page and anaylize. """
        for a in self.page:
            if self.gen_error_report:
                self.kbpc_rpt.write(
                    "\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
                    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n")
            if a[0:6] == "Report" or a[0:6] == "":
                pass
            else:
                if self.gen_error_report:
                    self.kbpc_rpt.write("Out of Sequence Problem!\n")
                self.eid_count = 0
            if self.gen_error_report:
                datainput = "Page: {}\n".format(self.page_num)
                self.kbpc_rpt.write(datainput)
            try:  # if the page has no station information, then break the loop.
                result = re.search("Restricted USPS T&A Information(.*)Employee Everything Report", a, re.DOTALL)
                station = result.group(1).strip()
                station = station.split('\n')[0]
                if len(station) == 0:
                    result = re.search("Employee Everything Report(.*)Weekly", a, re.DOTALL)
                    station = result.group(1).strip()
                    station = station.split('\n')[0]
            except:
                break
            # get the pay period
            try:
                result = re.search("YrPPWk:\nSub-Unit:\n\n(.*)\n", a)
                self.yyppwk = result.group(1)
            except:
                try:
                    result = re.search("YrPPWk:\n\n(.*)\n\nFin. #:", a)
                    self.yyppwk = result.group(1)
                except:
                    try:
                        result = re.findall(r'[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9]', text)
                        self.yyppwk = result[-1]
                    except:
                        pass
            if self.saved_pp != self.yyppwk:
                exploded = self.yyppwk.split("-")  # break up the year/pp string from the ee rpt pdf
                year = exploded[0]  # get the year
                if self.gen_error_report:
                    datainput = "Year: {}\n".format(year)
                    self.kbpc_rpt.write(datainput)
                pp = exploded[1]  # get the pay period
                if self.gen_error_report:
                    datainput = "Pay Period: {}\n".format(pp)
                    self.kbpc_rpt.write(datainput)
                pp_wk = exploded[2]  # get the week of the pay period
                if self.gen_error_report:
                    datainput = "Pay Period Week: {}\n".format(pp_wk)
                    self.kbpc_rpt.write(datainput)
                pp += pp_wk  # join the pay period and the week
                if len(pp) > 3:
                    pp = input("Enter the pay period as three digits: ")
                print(year, pp, self.yyppwk)
                first_date = find_pp(int(year), pp)  # get the first day of the pay period
                if self.gen_error_report:
                    datainput = "{}\n".format(str(first_date))
                    self.kbpc_rpt.write(datainput)
                self.pp_days = []  # build an array of date/time objects for each day in the pay period
                self.daily_array_days = []  # build an array of formatted days with just month/ day
                for _ in range(7):
                    self.pp_days.append(first_date)
                    self.daily_array_days.append(first_date.strftime("%m/%d"))
                    first_date += timedelta(days=1)
                if self.gen_error_report:
                    datainput = "Days in Pay Period: {}\n".format(self.pp_days)
                    self.kbpc_rpt.write(datainput)
                self.saved_pp = self.yyppwk  # hold the year/pp to check if it changes
            self.page_num += 1

            b = a.split("\n\n")
            for c in b:
                # find, categorize and record daily times
                if self.lookfortimes:
                    if re.match(r"0[0-9]{4}\:\s0[0-9]{2}\.[0-9]{2}$", c):
                        to_add = [self.base_counter, c]
                        self.base_time.append(to_add)
                        self.base_chg = self.base_counter  # value to check for errors+
                    # solve for robertson basetime problem / Base followed by H/L
                    elif re.match(r"0[0-9]{4}\:\s0[0-9]{2}\.[0-9]{2}\n0[0-9]{4}\:\s0[0-9]{2}\.[0-9]{2}", c):
                        if "\n" not in c:  # check that there are no multiple times in the line
                            to_add = [self.base_counter, c]
                            self.base_time.append(to_add)
                            self.base_chg = self.base_counter  # value to check for errors
                            self.robert_rpt.append(self.lastname)  # data for robertson baseline problem
                        elif "\n" in c:  # if there are multiple times in the line
                            split_base = c.split("\n")  # split the times by the line break
                            for sb in split_base:  # add each time individually
                                to_add = [self.base_counter, sb]  # combine the base counter with the time
                                self.base_time.append(to_add)  # add that time to the array of base times
                                self.base_chg = self.base_counter  # value to check for errors
                    else:
                        self.base_counter += 1
                        self.lookfortimes = False
                if re.match(r"Base", c):
                    self.lookfortimes = True
                # solve for stevens problem / H/L base times not being read
                if len(self.finance_holder) == 0 and re.match(r"H/L\s", c):  # set trap to catch daily times
                    self.lookfortimes = True
                    self.stevens_rpt.append(self.lastname)
                checker = False
                one_mistake = False
                underscore_slash = c.split("\n")
                for us in underscore_slash:  # loop through items to detect matches
                    if re.match(r"[0-1][0-9]\/[0-9][0-9]", us) or us == "__/__":
                        checker = True
                    else:
                        one_mistake = True
                if len(underscore_slash) > 1 and checker and not one_mistake:
                    self.daily_underscoreslash.append(underscore_slash)
                # underscore_slash = []

                d = c.split("\n")
                for e in d:
                    try:
                        # build the daily array
                        # get the route following the chain
                        if re.match(r"[0-9]{6}$", e) and len(self.movecode_holder) != 0:
                            self.movecode_holder.append(e)
                            route_holder = self.movecode_holder
                            if self.unprocessedrings == "":
                                self.daily_array.append(route_holder)
                            else:
                                self.unprocessed_counter += 1  # handle carroll problem
                                self.carroll_rpt.append(self.lastname)  # append carroll report
                        self.movecode_holder = []
                        if len(self.finance_holder) != 0:  # get the move code following the chain
                            if re.match(r"[0-9]{4}\-[0-9]{2}$", e):
                                self.finance_holder.append(e)
                                self.movecode_holder = self.finance_holder
                            # solve for robertson problem / "H/L" is in move code
                            if re.match(r"H/L", e):  # if the move code is a higher level assignment
                                self.finance_holder.append(e)
                                self.finance_holder.append("000000")  # insert zeros for route number
                                if self.unprocessedrings == "":
                                    self.daily_array.append(
                                        self.finance_holder)  # skip getting the route and create append daily array
                                else:
                                    self.unprocessed_counter += 1  # handle carroll problem
                                    self.carroll_rpt.append(self.lastname)  # append carroll report
                        self.finance_holder = []
                        if len(self.timezone_holder) != 0:  # get the finance number following the chain
                            self.timezone_holder.append(e)
                            self.finance_holder = self.timezone_holder
                        self.timezone_holder = []
                        if re.match(r"[A-Z]{2}T", e) and len(
                                self.time_holder) != 0:  # look for the time zone following chain
                            self.time_holder.append(e)
                            self.timezone_holder = self.time_holder
                        # solve for salih problem / missing time zone in ...
                        elif len(self.time_holder) != 0 and self.unprocessedrings != "":
                            self.unprocessed_counter += 1  # unprocessed rings
                            self.salih_rpt.append(self.lastname)
                        self.time_holder = []
                        # look for time following date/mv desig
                        if re.match(r" [0-2][0-9]\.[0-9][0-9]$", e) and len(self.date_holder) != 0:
                            self.date_holder.append(e)
                            self.time_holder = self.date_holder
                        # look for items in franklin array to solve for franklin problem
                        if len(self.franklin_array) > 0 and re.match(r"[0-1][0-9]\/[0-3][0-9]$",
                                                                e):  # if franklin array and date
                            frank = self.franklin_array.pop(0)  # pop out the earliest mv desig
                            self.mv_holder = [self.eid, frank]
                        # solve for rodriguez problem / multiple consecutive mv desigs
                        if len(self.franklin_array) > 0:
                            if re.match(r"0[0-9]{4}$", e) or re.match(r"0[0-9]{2}$",
                                                                      e) or e in self.mv_desigs:  # look for move desig
                                self.franklin_array.append(e)
                                self.rod_rpt.append(self.lastname)
                        self.date_holder = []
                        if re.match(r"[0-1][0-9]\/[0-3][0-9]$", e) and len(
                                self.mv_holder) != 0:  # look for date following move desig
                            self.mv_holder.append(e)
                            self.date_holder = self.mv_holder
                        # solve for franklin problem: two mv desigs appear consecutively
                        if len(self.mv_holder) > 0:
                            if re.match(r"0[0-9]{4}$", e) or re.match(r"0[0-9]{2}$",
                                                                      e) or e in self.mv_desigs:  # look for move desig
                                self.franklin_array.append(self.mv_holder[1])
                                self.franklin_array.append(e)
                                self.frank_rpt.append(self.lastname)
                        self.mv_holder = []
                        if len(self.franklin_array) == 0:
                            if re.match(r"0[0-9]{4}$", e) or re.match(r"0[0-9]{2}$",
                                                                      e) or e in self.mv_desigs:  # look for move desig
                                self.mv_holder.append(self.eid)
                                self.mv_holder.append(e)  # place in a holder and check the next line for a date
                        # solve for rose problem: mv desig and date appearing on same line
                        if re.match(r"0[0-9]{4}\s[0-2][0-9]\/[0-9][0-9]$", e):
                            rose = e.split(" ")
                            self.mv_holder.append(self.eid)  # add the emp id to the daily array
                            self.mv_holder.append(rose[0])  # add the mv desig to the daily array
                            self.mv_holder.append(rose[1])  # add the date to the mv desig array
                            self.date_holder = self.mv_holder  # transfer array items to date holder
                            self.rose_rpt.append(self.lastname)
                        if e in self.days:  # find and record all days on the report
                            if self.eid_label:
                                self.found_days.append(e)
                            if not self.eid_label:
                                self.foundday_holder.append(e)
                        if e == "Processed Clock Rings":
                            self.eid_count = 0
                        if e == "Employee ID":
                            self.eid_label = True
                            if self.gen_error_report:
                                if len(self.jobs) > 0:
                                    datainput = "Jobs: {}\n".format(self.jobs)
                                    self.kbpc_rpt.write(datainput)
                                if len(self.routes) > 0:
                                    datainput = "Routes: {}\n".format(self.routes)
                                    self.kbpc_rpt.write(datainput)
                                if len(self.level) > 0:
                                    datainput = "Levels: {}\n".format(self.level)
                                    self.kbpc_rpt.write(datainput)
                                if len(self.base_time) > 0:
                                    self.kbpc_rpt.write("Base / Times:")
                                    for bt in self.base_time:
                                        datainput = "{}\n".format(bt)
                                        self.kbpc_rpt.write(datainput)
                            if len(self.daily_underscoreslash) > 0:  # bind all underscore slash items in one array
                                self.underscore_slash_result = sum(self.daily_underscoreslash, [])
                            # write to csv file
                            prime_info = [self.yyppwk.replace("-", ""), '"{}"'.format("000000"), '"{}"'.format(station),
                                          '"{}"'.format("0000"), '"{}"'.format(self.eid), '"{}"'.format(self.lastname),
                                          '"{}"'.format(self.fi[:1]),
                                          '"_"', '"010/0000"', '"N"', '"N"', '"N"', '"0"', '"0"', '"0"', '"0"', '"0"',
                                          '"0"']
                            count = 0
                            for array in self.daily_array:
                                array.append(self.underscore_slash_result[count])
                                array.append(self.underscore_slash_result[count + 1])
                                count += 2
                            if self.base_chg + 1 != len(self.found_days):  # add to basecounter error array
                                to_add = (self.lastname, self.base_chg, len(self.found_days))
                                if len(self.found_days) > 0:
                                    self.basecounter_error.append(to_add)
                            # set up array for each day in the week
                            csv_sat = []
                            csv_sun = []
                            csv_mon = []
                            csv_tue = []
                            csv_wed = []
                            csv_thr = []
                            csv_fri = []
                            csv_output = [csv_sat, csv_sun, csv_mon, csv_tue, csv_wed, csv_thr, csv_fri]
                            # reorder the found days to ensure the correct order
                            self.found_days = self.pdf_converter_reorder_founddays()
                            # fix problem with miscounted base times
                            high_array = []
                            for bt in self.base_time:
                                high_array.append(bt[0])
                            if len(high_array) > 0:
                                high_num = max(high_array)
                                comp_array = []
                                for i in range(high_num + 1):
                                    comp_array.append(i)
                                del_array = []
                                for num in comp_array:
                                    if num in high_array:
                                        del_array.append(num)
                                error_array = comp_array
                                error_array = [x for x in error_array if x not in del_array]
                                error_array.reverse()
                                if len(error_array) > 0:
                                    for error_num in error_array:
                                        for bt in self.base_time:
                                            if bt[0] > error_num:
                                                bt[0] -= 1
                            # load the multi array with array for each day
                            if len(self.foundday_holder) > 0:
                                # solve for nguyen problem / day of week occurs prior to "employee id" label
                                self.found_days += self.foundday_holder
                                ordered_days = ["Saturday", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
                                                "Friday"]
                                for day in self.days:  # re order days into correct order
                                    if day not in self.found_days:
                                        ordered_days.remove(day)
                                self.found_days = ordered_days
                                # self.foundday_holder = []
                                self.nguyen_rpt.append(self.lastname)
                            if len(self.found_days) > 0:  # printe out found days
                                # reorder the found days to ensure the correct order
                                self.found_days = self.pdf_converter_reorder_founddays()
                                if self.gen_error_report:
                                    datainput = "Found days: {}\n".format(self.found_days)
                                    self.kbpc_rpt.write(datainput)
                            if self.gen_error_report:
                                datainput = "proto emp id counter: {}\n".format(self.eid_count)
                                self.kbpc_rpt.write(datainput)
                            for i in range(7):
                                for bt in self.base_time:
                                    if self.found_days[bt[0]] == self.days[i]:
                                        csv_output[i].append(bt)
                                for da in self.daily_array:
                                    if da[2] == self.pp_days[i].strftime("%m/%d"):
                                        csv_output[i].append(da)
                            for co in csv_output:  # for each time in the array, printe a line
                                for array in co:
                                    if self.gen_error_report:
                                        datainput = "{}\n".format(array)
                                        self.kbpc_rpt.write(datainput)
                                    # put the data into the csv file
                                    if len(array) == 2:  # if the line comes from base/time data
                                        add_this = [self.found_days[int(array[0])], '"_0-00"', '"{}"'.format(array[1])]
                                        whole_line = prime_info + add_this
                                        with open(self.new_file_path, 'a') as writeFile:  # add the line to the csv file
                                            self.writer = csv.writer(writeFile, dialect='myDialect')
                                            self.writer.writerow(whole_line)
                                    if len(array) == 10:  # if the line comes from daily array
                                        if array[9] != "__/__":
                                            end_notes = "(W)Ring Deleted From PC"
                                        else:
                                            end_notes = ""
                                        add_this = ["000-00", '"{}"'.format(array[1]),
                                                    '"{}"'.format(
                                                        self.pp_days[self.daily_array_days.index(array[2])].strftime(
                                                            "%d-%b-%y").upper()),
                                                    '"{}"'.format(array[3].strip()), '"{}"'.format(array[5]),
                                                    '"{}"'.format(array[6]),
                                                    '"{}"'.format(array[7]), '""', '""', '""', '"0"', '""', '""', '"0"',
                                                    '"{}"'.format(end_notes)]
                                        whole_line = prime_info + add_this
                                        with open(self.new_file_path, 'a') as writeFile:  # add the line to the csv file
                                            self.writer = csv.writer(writeFile, dialect='myDialect')
                                            self.writer.writerow(whole_line)
                            # define csv writer parameters
                            # csv.register_dialect('myDialect',
                            #                      delimiter=',',
                            #                      quotechar="'",
                            #                      skipinitialspace=True,
                            #                      lineterminator=",\r"
                            #                     )
                            if len(self.jobs) > 0:
                                for i in range(len(self.jobs)):
                                    base_line = [self.base_temp[i], '"{}"'.format(self.jobs[i].replace("-", "").strip()),
                                                 '"0000"', '"7220-10"',
                                                 '"Q0"', '"{}"'.format(self.level[i]), '"N"',
                                                 '"{}"'.format(self.routes[i]), '""',
                                                 '"0000000"',
                                                 '"0000000"', '"0"', '"0"', '"0"', '"N"', '"N"', '"N"', '"MDT"', '"N"']
                                    whole_line = prime_info + base_line
                                    with open(self.new_file_path, 'a') as writeFile:
                                        self.writer = csv.writer(writeFile, dialect='myDialect')
                                        self.writer.writerow(whole_line)
                            self.found_days = []  # initialized arrays
                            self.lookfortimes = False
                            self.base_time = []
                            self.eid = ""
                            self.base_chg = 0
                            self.base_counter = 0
                            self.daily_array = []
                            self.daily_underscoreslash = []
                            self.unprocessed_counter = 0
                            self.jobs = []
                            self.level = []
                            if self.gen_error_report:
                                datainput = "{}\n".format(e)
                                self.kbpc_rpt.write(datainput)
                            self.eid_count = 0
                        if self.lookforfi:  # look for first initial
                            if re.fullmatch("[A-Z]\s[A-Z]", e) or re.fullmatch("([A-Z])", e):
                                if self.gen_error_report:
                                    datainput = "FI: {}\n".format(e)
                                    self.kbpc_rpt.write(datainput)
                                self.fi = e
                                self.lookforfi = False
                        if self.lookforname:  # look for the name
                            if re.fullmatch(r"([A-Z]+)", e) \
                                    or re.fullmatch(r"([A-Z]+.[A-Z]+)", e) \
                                    or re.fullmatch(r"([A-Z]+.[A-Z]+.[A-Z]+)", e) \
                                    or re.fullmatch(r"([A-Z]+.[A-Z]+.[A-Z]+.[A-Z]+)", e) \
                                    or re.fullmatch(r"([A-Z]+.[A-Z]+.[A-Z]+.[A-Z]+.[A-Z]+)", e):
                                self.lastname = e.replace("'", " ")
                                if self.gen_error_report:
                                    datainput = "Name: {}\n".format(e)
                                    self.kbpc_rpt.write(datainput)
                                self.lookforname = False
                                self.lookforfi = True
                        if re.match(r"\s[0-9]{2}\-[0-9]$", e):  # find the job or d/a code - there might be two
                            self.jobs.append(e)
                        if self.lookfor2route:  # look for temp route
                            if re.match(r"[0-9]{6}$", e):
                                self.routes.append(e)  # add route to routes array
                            self.lookfor2route = False
                        if self.lookforroute:  # look for main route
                            if re.match(r"[0-9]{6}$", e):  #
                                self.routes.append(e)  # add route to routes array
                                self.lookfor2route = True
                            self.lookforroute = False
                        if e == "Route #":  # set trap to catch route # on the next line
                            self.lookforroute = True
                        if self.lookfor2level:  # intercept the second level
                            if re.match(r"[0-9]{2}$", e):
                                self.level.append(e)
                            self.lookfor2level = False
                        if self.lookforlevel:  # intercept the level
                            if re.match(r"[0-9]{2}$", e):
                                self.level.append(e)
                                self.lookfor2level = True  # set trap to catch the second level next line
                            self.lookforlevel = False
                        if e == "Lvl":  # set trap to catch Lvl on the next line
                            self.lookforlevel = True
                        if self.eid != "" and self.new_page == False:
                            if re.match(r"[0-9]{8}", e):  # find the underscore dash string
                                self.eid_count += 1
                            if re.match(r"xxx\-xx\-[0-9]{4}", e):
                                self.eid_count += 1
                            if re.match(r"XXX\-XX\-[0-9]{4}", e):
                                self.eid_count += 1
                            if e == "___-___-____":
                                self.eid_count += 1
                            # solve for rose problem: time object is fused to emp id object - just increment the
                            # eid counter
                            if re.match(r"\s[0-9]{2}\.[0-9]{10}", e) \
                                    or re.match(r"__.__[0-9]{8}", e) \
                                    or re.match(r"__._____-___-____", e):
                                self.eid_count += 1
                                self.rose_rpt.append(self.lastname)
                        # solve for carroll problem/ unprocessed rings do not have underscore slash counterparts
                        if e == "Un-Processed Rings":  # after unprocessed rings label, add no new rings to daily array
                            self.unprocessedrings = self.eid
                        if re.match(r"[0-9]{8}", e):  # find the emp id / it is the first 8 digit number on the page
                            if self.eid_count == 0:
                                self.eid = e
                                if self.gen_error_report:
                                    datainput = "Employee ID: {}\n".format(e)
                                    self.kbpc_rpt.write(datainput)
                                self.lookforname = True
                                if self.eid != self.unprocessedrings:  # set unprocessedrings and new_page variables
                                    self.unprocessedrings = ""
                                    self.new_page = False
                                else:
                                    self.new_page = True
                                    # increment the self.eid counter to stop new self.eid from being set
                                    self.eid_count += 1
                                    if self.gen_error_report:
                                        self.kbpc_rpt.write("NEW PAGE!!!\n")
                    except:
                        self.failed.append(self.lastname)
                        datainput = "READING FAILURE: {}\n".format(e)
                        self.kbpc_rpt.write(datainput)
            if self.gen_error_report:  # write to error report
                datainput = "Station: {}\n".format(station)
                self.kbpc_rpt.write(datainput)
                datainput = "Pay Period: {}\n".format(self.yyppwk)
                self.kbpc_rpt.write(datainput)  # show the pay period
                if len(self.jobs) > 0:
                    datainput = "Jobs: {}\n".format(self.jobs)
                    self.kbpc_rpt.write(datainput)
                if len(self.routes) > 0:
                    datainput = "Routes: {}\n".format(self.routes)
                    self.kbpc_rpt.write(datainput)
                if len(self.level) > 0:
                    datainput = "Levels: {}\n".format(self.level)
                    self.kbpc_rpt.write(datainput)
            # define csv writer parameters
            # csv.register_dialect('myDialect',
            #                      delimiter=',',
            #                      quotechar="'",
            #                      skipinitialspace=True,
            #                      lineterminator=",\r"
            #                      )
            # write to csv file
            prime_info = [self.yyppwk.replace("-", ""), '"{}"'.format("000000"), '"{}"'.format(station),
                          '"{}"'.format("0000"), '"{}"'.format(self.eid), '"{}"'.format(self.lastname),
                          '"{}"'.format(self.fi[:1]),
                          '"_"', '"010/0000"', '"N"', '"N"', '"N"', '"0"', '"0"', '"0"', '"0"', '"0"', '"0"']
            if len(self.jobs) > 0:
                # if the route count is less than the jobs count, fill the route count
                self.routes = PdfConverterFix(self.routes).route_filler(len(self.jobs))
                for i in range(len(self.jobs)):
                    base_line = [self.base_temp[i], '"{}"'.format(self.jobs[i].replace("-", "").strip()),
                                 '"0000"', '"7220-10"',
                                 '"Q0"', '"{}"'.format(self.level[i]), '"N"', '"{}"'.format(self.routes[i]),
                                 '""', '"0000000"',
                                 '"0000000"', '"0"', '"0"', '"0"', '"N"', '"N"', '"N"', '"MDT"', '"N"']
                    whole_line = prime_info + base_line
                    with open(self.new_file_path, 'a') as writeFile:
                        self.writer = csv.writer(writeFile, dialect='myDialect')
                        self.writer.writerow(whole_line)
            if len(self.foundday_holder) > 0:
                # solve for nguyen problem / day of week occurs prior to "employee id" label
                self.found_days += self.foundday_holder
                ordered_days = ["Saturday", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
                for day in self.days:  # re order days into correct order
                    if day not in self.found_days:
                        ordered_days.remove(day)
                self.found_days = ordered_days
                # self.foundday_holder = []
                self.nguyen_rpt.append(self.lastname)
            if len(self.found_days) > 0:  # printe out found days
                # reorder the found days to ensure the correct order
                self.found_days = self.pdf_converter_reorder_founddays()
                if self.gen_error_report:
                    datainput = "Found days: {}\n".format(self.found_days)
                    self.kbpc_rpt.write(datainput)
            if self.gen_error_report:
                datainput = "proto emp id counter: {}\n".format(self.eid_count)
                self.kbpc_rpt.write(datainput)
            if len(self.daily_underscoreslash) > 0:  # bind all underscore slash items in one array
                self.underscore_slash_result = sum(self.daily_underscoreslash, [])
            if self.mcgrath_indicator and len(self.underscore_slash_result) > 0:  # solve for mcgrath indicator
                self.mcgrath_carryover.append(self.underscore_slash_result[0])  # add underscore slash to carryover
                self.mcgrath_indicator = False  # reset the indicator
                if self.gen_error_report:
                    datainput = "MCGRATH CARRYOVER: {}\n".format(self.mcgrath_carryover)
                    self.kbpc_rpt.write(datainput)  # printe out a notice.
                del self.underscore_slash_result[0]  # delete the ophan underscore slash
            count = 0
            for array in self.daily_array:
                array.append(self.underscore_slash_result[count])
                try:
                    array.append(self.underscore_slash_result[count + 1])
                except:  # solve for the mcgrath problem
                    self.mcgrath_carryover = array
                    self.mcgrath_indicator = True
                    self.mcgrath_rpt.append(self.lastname)
                    if self.gen_error_report:
                        self.kbpc_rpt.write("MCGRATH ERROR DETECTED!!!\n")
                # if self.mcgrath_indicator == False:
                count += 2
            # if there is a carryover, remove the daily array item from the list
            if self.mcgrath_carryover in self.daily_array:
                self.daily_array.remove(self.mcgrath_carryover)
            if not self.mcgrath_indicator and self.mcgrath_carryover != "":  # if there is a carryover to be added
                self.daily_array.insert(0, self.mcgrath_carryover)  # put the carryover at the front of the daily array
                self.mcgrath_carryover = ""  # reset the carryover
                self.eid_count += 1  # increment the emp id counter
            # set up array for each day in the week
            csv_sat = []
            csv_sun = []
            csv_mon = []
            csv_tue = []
            csv_wed = []
            csv_thr = []
            csv_fri = []
            csv_output = [csv_sat, csv_sun, csv_mon, csv_tue, csv_wed, csv_thr, csv_fri]
            # reorder the found days to ensure the correct order
            self.found_days = self.pdf_converter_reorder_founddays()
            # fix problem with miscounted base times
            high_array = []
            for bt in self.base_time:
                high_array.append(bt[0])
            if len(high_array) > 0:
                high_num = max(high_array)
                comp_array = []
                for i in range(high_num + 1):
                    comp_array.append(i)
                del_array = []
                for num in comp_array:
                    if num in high_array:
                        del_array.append(num)
                error_array = comp_array
                error_array = [x for x in error_array if x not in del_array]
                error_array.reverse()
                if len(error_array) > 0:
                    for error_num in error_array:
                        for bt in self.base_time:
                            if bt[0] > error_num:
                                bt[0] -= 1
            # load the multi array with array for each day
            for i in range(7):
                for bt in self.base_time:
                    if self.found_days[bt[0]] == self.days[i]:
                        csv_output[i].append(bt)
                for da in self.daily_array:
                    if da[2] == self.pp_days[i].strftime("%m/%d"):
                        csv_output[i].append(da)
            for co in csv_output:  # for each time in the array, printe a line
                for array in co:
                    if self.gen_error_report:
                        datainput = "{}\n".format(str(array))
                        self.kbpc_rpt.write(datainput)
                    # put the data into the csv file
                    if len(array) == 2:  # if the line comes from base/time data
                        add_this = [self.found_days[int(array[0])], '"_0-00"', '"{}"'.format(array[1])]
                        whole_line = prime_info + add_this
                        with open(self.new_file_path, 'a') as writeFile:  # add the line to the csv file
                            self.writer = csv.writer(writeFile, dialect='myDialect')
                            self.writer.writerow(whole_line)
                    if len(array) == 10:  # if the line comes from daily array
                        if array[9] != "__/__":
                            end_notes = "(W)Ring Deleted From PC"
                        else:
                            end_notes = ""
                        add_this = ["000-00", '"{}"'.format(array[1]),
                                    '"{}"'.format(self.pp_days[self.daily_array_days.index(array[2])].
                                                  strftime("%d-%b-%y").upper()),
                                    '"{}"'.format(array[3].strip()), '"{}"'.format(array[5]), '"{}"'.format(array[6]),
                                    '"{}"'.format(array[7]), '""', '""', '""', '"0"', '""', '""', '"0"',
                                    '"{}"'.format(end_notes)]
                        whole_line = prime_info + add_this
                        with open(self.new_file_path, 'a') as writeFile:  # add the line to the csv file
                            self.writer = csv.writer(writeFile, dialect='myDialect')
                            self.writer.writerow(whole_line)
            # Handle Carroll problems
            if not self.mcgrath_indicator:
                if self.eid_count == 1:  # handle widows
                    self.eid_count = 0
                    if self.gen_error_report:
                        datainput = "WIDOW HANDLING: Carroll Mod emp id counter: {}\n".format(self.eid_count)
                        self.kbpc_rpt.write(datainput)
                elif self.eid_count % 2 != 0:  # handle self.eid counts where there has been a cut off
                    self.eid_count += 1
                    if self.gen_error_report:
                        datainput = "CUT OFF CONTROL: Carroll Mod emp id counter: {}\n".format(self.eid_count)
                        self.kbpc_rpt.write(datainput)
            else:
                self.eid_count -= 1
            self.eid_count -= self.unprocessed_counter * 2

            if self.unprocessed_counter > 0:
                if self.gen_error_report:
                    datainput = "Unprocessed Rings: {}\n".format(self.unprocessed_counter)
                    self.kbpc_rpt.write(datainput)
                if len(self.daily_array) == self.eid_count / 2:
                    pass
                # Solve for Unruh error / when a underscore dash is missing after unprocessed rings
                elif len(self.daily_array) == max((self.eid_count + 2) / 2, 0):
                    if self.gen_error_report:
                        datainput = "Unruh Mod emp id counter: {}\n".format(self.eid_count + 2)
                        self.kbpc_rpt.write(datainput)
                        self.kbpc_rpt.write("UNRUH PROBLEM DETECTED!!!")
                    self.unruh_rpt.append(self.lastname)
                else:
                    if self.gen_error_report:
                        self.kbpc_rpt.write(
                            "FRANKLIN ERROR DETECTED!!! ALERT! (Unprocessed counter)!\n")
                    self.unresolved.append(self.lastname)
            else:
                if len(self.daily_array) != max(self.eid_count / 2, 0):
                    if self.gen_error_report:
                        self.kbpc_rpt.write("FRANKLIN ERROR DETECTED!!! ALERT! ALERT!\n")
                    self.unresolved.append(self.lastname)
            if self.base_chg + 1 != len(self.found_days):  # add to basecounter error array
                to_add = (self.lastname, self.base_chg, len(self.found_days))
                if len(self.found_days) > 0:
                    self.basecounter_error.append(to_add)
            if self.gen_error_report:
                datainput = "daily array lenght: {}\n".format(len(self.daily_array))
                self.kbpc_rpt.write(datainput)
            # initialize arrays
            self.found_days = []
            self.foundday_holder = []
            self.base_time = []
            self.eid = ""
            self.eid_label = False
            # perez_switch = False
            self.base_counter = 0
            self.base_chg = 0
            self.daily_array = []
            self.daily_underscoreslash = []
            self.unprocessed_counter = 0
            self.jobs = []
            self.routes = []
            self.level = []
            self.franklin_array = []
            if self.gen_error_report:
                datainput = "emp id counter: {}\n".format(max(self.eid_count, 0))
                self.kbpc_rpt.write(datainput)
            self.pb.move_count(self.pbi)
            self.pbi += 1
        # end loop
        self.endtime = time.time()

    def pdf_converter_reorder_founddays(self):
        """ makes sure the days are in the proper order. """
        new_order = []
        correct_series = ("Saturday", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
        for cs in correct_series:
            if cs in self.found_days:
                new_order.append(cs)
        return new_order

    def build_error_report(self):
        """ create a text document with the data stored in variables to show detected errors which are
        corrected by the their respective handlings. """
        if self.gen_error_report:
            self.kbpc_rpt.write("Potential Problem Reports _________________________________________________\n")
            datainput = "runtime: {} seconds\n".format(round(self.endtime - self.starttime, 4))
            self.kbpc_rpt.write(datainput)
            self.kbpc_rpt.write("Franklin Problems: Consecutive MV Desigs \n")
            datainput = "\t>>> {}\n".format(self.frank_rpt)
            self.kbpc_rpt.write(datainput)
            self.kbpc_rpt.write("Rodriguez Problem: This is the Franklin Problem X 4. \n")
            datainput = "\t>>> {}\n".format(self.rod_rpt)
            self.kbpc_rpt.write(datainput)
            self.kbpc_rpt.write("Rose Problem: The MV Desig and date are on the same line.\n")
            datainput = "\t>>> {}\n".format(self.rose_rpt)
            self.kbpc_rpt.write(datainput)
            self.kbpc_rpt.write("Robertson Baseline Problem: The base count is jumping when H/L basetimes "
                           "are put into the basetime array.\n")
            datainput = "\t>>> {}\n".format(self.robert_rpt)
            self.kbpc_rpt.write(datainput)
            self.kbpc_rpt.write("Stevens Problem: Basetimes begining with H/L do not show up and are "
                           "not entered into the basetime array.\n")
            datainput = "\t>>> {}\n".format(self.stevens_rpt)
            self.kbpc_rpt.write(datainput)
            self.kbpc_rpt.write("Carroll Problem: Unprocessed rings at the end of the page do not "
                                "contain __/__ or times.'n")
            datainput = ">>> {}\n".format(self.carroll_rpt)
            self.kbpc_rpt.write(datainput)
            self.kbpc_rpt.write("Nguyen Problem: Found day appears above the Emp ID.\n")
            datainput = "\t>>> {}\n".format(self.nguyen_rpt)
            self.kbpc_rpt.write(datainput)
            self.kbpc_rpt.write("Unruh Problem: Underscore dash cut off in unprecessed rings.\n")
            datainput = "\t>>> {}\n".format(self.unruh_rpt)
            self.kbpc_rpt.write(datainput)
            self.kbpc_rpt.write(
                "Salih Problem: Unprocessed rings are missing a timezone, so that unprocessed rings counter is not"
                " incremented.\n")
            datainput = "\t>>> {}\n".format(self.salih_rpt)
            self.kbpc_rpt.write(datainput)
            self.kbpc_rpt.write("McGrath Problem: \n")
            datainput = " \t>>> {}\n".format(self.mcgrath_rpt)
            self.kbpc_rpt.write(datainput)
            datainput = "Unresolved: {}\n".format(self.unresolved)
            self.kbpc_rpt.write(datainput)
            datainput = "Base Counter Error: {}\n".format(self.basecounter_error)
            self.kbpc_rpt.write(datainput)

    def error_messagebox(self):
        """ show any failures in a messagebox at the end of the conversion process. """
        if len(self.failed) > 0:  # create messagebox to show any errors
            failed_daily = ""  # initialize a text string
            for f in self.failed:
                failed_daily = failed_daily + " \n " + f  # add to the text string - name and new line for each name.
            messagebox.showerror("Klusterbox PDF Converter",
                                 "Errors have occured for the following carriers {}."
                                 .format(failed_daily),
                                 parent=self.frame)

    def completion_messagebox(self):
        """ create messagebox for completion """
        messagebox.showinfo("Klusterbox PDF Converter",
                            "The PDF Convertion is complete. "
                            "The file name is {}. ".format(self.short_file_name),
                            parent=self.frame)

